{--
Exercícios 5.6, 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.15, ....
Semana que vêm a lista será completada como exercícios de I/O.
--}
--5.6
infixr 5 :.:
type Par = (String, Int)
data Itemtype a = Vazia | a :.: (Itemtype a) -- Cons é meu construtor
    deriving(Show)

--14.1
type Name = String
type Book = Int
data People = People Name Book
    deriving(Show, Read)

--14.2
data Person = Person {
    autor :: String, 
    cds :: String,
    videos :: String,
    book :: String
    }deriving (Show, Eq)


--14.3 Give calculations
{-
eval (Lit 67) = 67
eval (Add (Sub (Lit 3) (Lit 1)) (Lit 3) = 
(eval (Lit 3) - eval (Lit 1)) + eval (Lit 3) =
(3 - 1) + 3 = 5
show' (Add (Lit 67) (Lit (-34))) = 
"(show' (Lit 67)) + (show' (Lit(-34)))" ==
"(67 + (-34))"
-}

{-14.4 Defina uma função que conta os números de
operadores em uma expressão
-}
-- size :: Expr -> Integer
-- size (Lit n) = 0
-- size (Add e1 e2) = 1 + (size e1) + (size e2)
-- size (Sub e1 e2) = 1 + (size e1) + (size e2)
-- size (Mul e1 e2) = 1 + (size e1) + (size e2)
-- size (Div e1 e2) = 1 + (size e1) + (size e2)


{-14.5
Adicione as operações de multiplicação e divisão inteira ao
tipo Expr e redefina as funções eval, show e size para incluir esses novos casos.
O que sua definição de eval faz quando solicitada uma a executar uma divisão por zero ?
    >> eval (Add (Div (Lit 5) (Lit 0)) (Sub (Lit 5) (Lit 4)))
    >> Infinity
-}
-- data Expr = Lit Float |
--             Add Expr Expr |
--             Sub Expr Expr |
--             Div Expr Expr |
--             Mul Expr Expr
--             deriving (Show, Read)


data Expr = Lit Float |
            Op Ops Expr Expr | 
            If BExp Expr Expr
            deriving (Show, Read)

data BExp = BooLit Bool |
            And BExp BExp |
            Not BExp |
            Equal Expr Expr |
            Greater Expr Expr
            deriving (Show, Read)

data Ops = Add | Sub | Mul | Div
    deriving (Show, Read)

show' :: Expr -> String
show' (Lit n) = show n 
show' (Op Add e1 e2) ="(" ++ show' e1 ++ " + " ++ show' e2 ++ ")"
show' (Op Sub e1 e2) ="(" ++ show' e1 ++ " - " ++ show' e2 ++ ")"
show' (Op Div e1 e2) ="(" ++ show' e1 ++ " / " ++ show' e2 ++ ")"
show' (Op Mul e1 e2) ="(" ++ show' e1 ++ " * " ++ show' e2 ++ ")"

{-14.15-}
eval :: Expr -> Float
eval (Lit n) = n
eval (Op Add e1 e2) = (eval e1) + (eval e2)
eval (Op Sub e1 e2) = (eval e1) - (eval e2)
eval (Op Div e1 e2) = (eval e1) / (eval e2)
eval (Op Mul e1 e2) = (eval e1) * (eval e2)

bEval :: BExp -> Bool
bEval (BooLit b) = b
bEval (And e1 e2) = (bEval e1) == (bEval e2)
bEval (Not e1) = not (bEval e1)
bEval (Equal e1 e2) = (eval e1) == (eval e2) -- Recursão mútua aqui, estou chamando eval.
bEval (Greater e1 e2) = (eval e1) > (eval e2) -- Recursão mútua aqui, estou chamando eval.

-- Testando com os valores
-- bEval (Equal (Op Add (Lit 2) (Lit 2)) (Op Sub (Lit 10) (Lit 6))

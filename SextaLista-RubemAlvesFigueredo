Do livro Haskell: The craft of functional programming, 3d ed, os exercícios
9.5, 9.6, 9.7, 9.9, 9.11,
11.25, 11.26, 11.29, 11.32 e 11.33

 =========================================================================
           ====================== CAP 9 =========================
 9.5
Caso Base:
(I)        sum ([] ++ ys) == sum ys

(II)       sum [] + sum ys == 0 + sum ys == sum ys
    (I) == (II)

Indução
    (III):
        sum ((x : xs) ++ ys) == sum ([x] ++ xs ++ ys) == x + sum (xs ++ ys)
        == x + sum xs + sum ys
    (IV):
        sum (x : xs) + sum ys == x + sum xs + sum ys == x + sum (xs ++ ys)
    (III) == (IV)

--========================================================================

9.6
xs ++ [] == xs
Caso Base:
    [] ++ [] == LHS
    [] == RHS
    [] == [] ++ []
    LHS == RHS
Indução:
    (x : xs) ++ [] == (x : (xs ++ []))   (I)
    hipótese: \-/x  xs ++ [] == xs
    Aplicação da hipótese:
     == (x : xs)                         (II)

xs ++ (ys ++ zs) == (xs ++ ys) ++ zs

Caso Base:
    [] ++ (ys ++ zs) == (ys ++ zs) == ([] ++ ys) ++ zs
Indução:
    Teorema: (x : xs) ++ ps == x : (xs ++ ps)
    (x : xs) ++ (ys ++ zs) == x : (xs ++ (ys ++ zs)) == x : ((xs ++ ys) ++ zs)
    == (x : (xs ++ ys) ++ zs) == (((x : xs) ++ ys) ++ zs)
--========================================================================

9.7
sum (reverse xs) == sum xs

Caso Base:
    sum (reverse []) == 0 == sum []
Indução:
    sum (reverse (x : xs)) == sum (xs ++ [x]) == x + sum xs    (I)
    sum (x : xs) == x + sum xs                                 (II)
    (I) == (II)

length (reverse xs) == length xs

Caso Base:
    length (reverse []) == length [] == 0
Indução:
    length (reverse (x : xs)) == length (xs ++ [x]) == 1 + length xs   (I)
    length (x : xs) == 1 + length xs                                   (II)
    (I) == (II)

--=========================================================================

9.9
zip (fst (unzip ps)) (snd (unzip ps)) == ps

Caso Base:
    zip (fst (unzip ([], []))) (snd (unzip ([], []))) == zip [] [] == ([], [])

Indução:
    zip (fst (unzip (x : xs, y : ys))) (snd (unzip (x : xs, y : ys)))
    == zip (x : xs) (y : ys) == (x : xs, y : ys)

--=========================================================================

9.11
